read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
load("datos/historico_cuentas.RData")
weatherData <- reactive({
invalidateLater(5000, session)
N <- min((as.numeric(Sys.time()) - startTime)/5 + 30, 1000)
load("datos/historico_cuentas.RData")
})
weatherData
weatherData <- weatherData()
weatherData <- reactive({
invalidateLater(5000, session)
N <- min((as.numeric(Sys.time()) - startTime)/5 + 30, 1000)
read.csv("Shiny/Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
})
output$data <- renderPrint(weatherData())
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
install.packages("DT")
runApp('Shiny')
install.packages("htmlwidgets")
runApp('Shiny')
library("htmlwidgets", lib.loc="~/R/R-3.4.2/library")
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
detach("package:htmlwidgets", unload=TRUE)
detach("package:htmlwidgets", unload=TRUE)
library("htmlwidgets", lib.loc="~/R/R-3.4.2/library")
runApp('Shiny')
shiny::runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
historico.menciones
load("../datos/historico_seguidores.RData")
load("datos/historico_seguidores.RData")
historico_seguidores
historico.seguidores
runApp('Shiny')
load("datos/historico_tweets.RData")
historico.tweets
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
View(historico.tweets)
filter(historico.tweets,geo_coords!=c("NA","NA"))
filter(historico.tweets,geo_coords!=c(NA,NA))
filter(historico.tweets,geo_coords!=c(,))
table(historico.tweets$geo_coords)
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets %>% select(-ends_with("coords"))
historico.tweets$media_url
historico.tweets$hashtags
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select_if(is.list == FALSE)
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select_if(is.vector == FALSE)
str(historico.tweets$symbols)
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select_if(is.list == FALSE)
historico.tweets
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select(-ends_with("coords")) %>% select(-hashtags:mentions_screen_name)
historico.tweets <- historico.tweets %>% select(-ends_with("coords"))
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select(-ends_with("coords")) %>% select(-hashtags:mentions_screen_name)
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select(-ends_with("coords")) %>% select(-c(hashtags:mentions_screen_name)
startTime <- as.numeric(Sys.time())
weatherData <- reactive({
invalidateLater(5000, session)
N <- min((as.numeric(Sys.time()) - startTime)/5 + 30, 1000)
read.csv("Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
})
# Graficas ----
# ·······························································································
output$temp <- renderPlot({
weatherData<- weatherData()
qplot(Dates, Temperature, data = weatherData, geom = "line")
})
output$rain <- renderPlot({
weatherData<- weatherData()
ggplot(data = weatherData(), aes(Dates, Rainfall)) +
geom_bar(stat = "identity")
})
output$maxTemp <- renderValueBox({
weatherData <- weatherData()
maxTemp <- max(weatherData$Temperature, na.rm = TRUE)
valueBox(maxTemp,
subtitle = "Maximum Temperature (celsius)",
icon     = icon("arrow-up"),
color    = "light-blue")
})
output$minTemp <- renderValueBox({
weatherData <- weatherData()
minTemp <- min(weatherData$Temperature, na.rm = TRUE)
valueBox(minTemp,
subtitle = "Minimum Temperature (celsius)",
icon     = icon("arrow-down"),
color    = "light-blue")
})
output$averageRainfall <- renderValueBox({
weatherData <- weatherData()
meanRain <- round(mean(weatherData$Rainfall, na.rm = TRUE),1)
valueBox(meanRain,
subtitle = "Average Monthly rainfall (mm)",
icon     = icon("cloud"),
color    = "orange")
})
# Creamos las tablas de datos
output$tb1 <- DT::renderDataTable(show_tabla(historico.cuentas,    input$show_cuentas))
output$tb2 <- DT::renderDataTable(show_tabla(historico.tweets,     input$show_tweets))
output$tb3 <- DT::renderDataTable(show_tabla(historico.menciones,  input$show_menciones))
output$tb4 <- DT::renderDataTable(show_tabla(historico.seguidores, input$show_seguidores))
}
)
# Limpiamos los datos de los tweets para quitar los vectores de localizacion
historico.tweets <- historico.tweets %>% select(-ends_with("coords")) %>% select(-c(hashtags:mentions_screen_name))
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
load("../datos/historico_menciones.RData")
load("datos/historico_menciones.RData")
historico.menciones <- historico.menciones %>% select(-ends_with("coords")) %>%
select(-c(hashtags:mentions_screen_name))
runApp('Shiny')
load("datos/historico_menciones.RData")
runApp('Shiny')
historico.menciones
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
historico.seguidores
load("datos/historico_seguidores.RData")
historico.seguidores
runApp('Shiny')
a=names(historico.tweets)
load("datos/historico_tweets.RData")
a=names(historico.tweets)
a
a %>% select(-ends_with("coords"))
a %>% (-ends_with("coords"))
a %>% filter(-ends_with("coords"))
a %>% filter(ends_with("coords"))
str(historico.tweets)
select_if(historico.tweets,is.list)
historico.tweets
select_if(historico.tweets,is.list == FALSE)
select_if(historico.tweets,!is.list)
select_if(historico.tweets,negate(is.list))
datos=historico.tweets
datos %>% select_if(negate(is.list)) %>% names()
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
runApp('Shiny')
histotico.seguidores
# Obtenemos la informacion de historico
load("datos/historico_seguidores.RData")
histotico.seguidores
View(historico.seguidores)
# Obtenemos el historico de tweets
load("datos/historico_tweets.RData")
View(historico.tweets)
indicadores_tweets <- function(tweets, filtro = "users"){
indicadores <- right_join(usuarios, tweets, by = c("users" = "screen_name")) %>%
group_by(mes = floor_date(created_at, "month")) %>%
group_by_(filtro, add = TRUE) %>%
summarise(n.tweets                  = n() ,
n.tweets.propios          = sum(is_retweet == FALSE),
n.tweets.retweets         = sum(is_retweet == TRUE),
n.tweets.respuestas       = sum(!is.na(reply_to_user_id)),
n.retweets                = sum(retweet_count),
n.like                    = sum(favorite_count),
n.like.tweets.propios     = sum(favorite_count[is_retweet == FALSE]),
n.retweets.tweets.propios = sum(retweet_count[is_retweet == FALSE])) %>%
ungroup()
return(indicadores)
}
a=indicadores_tweets(historico.tweets)
# Inicializamos todo lo necesario
source("R/librerias.R")
source("R/variables_globales.R")
source("R/funciones.R")
a=indicadores_tweets(historico.tweets)
View(a)
shiny::runApp('Shiny')
View(historico.tweets)
# Inicializamos todo lo necesario
source("R/librerias.R")
source("R/inicio_twitter.R")
source("R/variables_globales.R")
source("R/funciones.R")
# Filtros
filtro.usuarios <- c("generalitat",
"ChicoteAngel")
filtro.fecha.inicio <- as_date("2018-03-18")
filtro.fecha.final  <- as_date("2018-06-18")
# Obtenemos la informacion de los usuarios deseados
cuentas.filtradas <- historico.cuentas %>% filter(screen_name %in% filtro.usuarios)
# Obtenemos la informacion de historico
load("datos/historico_cuentas.RData")
# Obtenemos la informacion de los usuarios deseados
cuentas.filtradas <- historico.cuentas %>% filter(screen_name %in% filtro.usuarios)
cuentas.filtradas
install.packages("lintr")
library("lintr")
install.packages("covr")
vignette("how_it_works", package = "covr")
source("R/extraccion_seguidores.R")
install.packages("runjags")
logErr <- function() {
# turn logging callback off while we process errors separately
tcbm$suspend(TRUE)
# turn them back on when we're done
on.exit(tcbm$suspend(FALSE))
sc <- sys.calls()
sclen <- length(sc)  # last call is this function call
if(sclen > 1L) {
cat("myError:\n", do.call(paste, c(lapply(sc[-sclen], deparse), sep="\n")), "\n")
} else {
# syntax error, so no call stack
# show the last line entered
# (this won't be helpful if it's a parse error in a function)
file1 <- tempfile("Rrawhist")
savehistory(file1)
rawhist <- readLines(file1)
unlink(file1)
cat("myError:\n", rawhist[length(rawhist)], "\n")
}
}
options(error=logErr)
# top-level callback handler
log <- function(expr, value, ok, visible) {
cat(deparse(expr), "\n")
TRUE
}
tcbm <- taskCallbackManager()
tcbm$add(log, name = "log")
f <- function() stop("error")
hi
f()
obtener_series <- function(datos,tipo) {
if(tipo = "users"){
vector <- c("followers_count",
"friends_count",
"listed_count",
"statuses_count",
"favourites_count")
inicio <- min(historico.cuentas$extraccion)
}
serie.temporal <-  ts(datos[, vector],
start = c(year(inicio), month(inicio)),
frequency = 12)
return(serie.temporal)
}
obtener_series <- function(datos,tipo) {
if(tipo = "users"){
vector <- c("followers_count",
"friends_count",
"listed_count",
"statuses_count",
"favourites_count")
inicio <- min(historico.cuentas$extraccion)
}
serie.temporal <-  ts(datos[, vector],
start = c(year(inicio), month(inicio)),
frequency = 12)
return(serie.temporal)
}
obtener_series <- function(datos,tipo) {
if(tipo = "users"){
vector <- c("followers_count",
"friends_count",
"listed_count",
"statuses_count",
"favourites_count")
inicio <- min(historico.cuentas$extraccion)
}
serie.temporal <-  ts(datos[, vector],
start = c(year(inicio), month(inicio)),
frequency = 12)
return(serie.temporal)
}
obtener_series <- function(datos,tipo) {
if(tipo = "users"){
vector <- c("followers_count",
"friends_count",
"listed_count",
"statuses_count",
"favourites_count")
inicio <- min(historico.cuentas$extraccion)
}
serie.temporal <-  ts(datos[, vector],
start = c(year(inicio), month(inicio)),
frequency = 12)
return(serie.temporal)
}
dcar_normal()
shiny::runApp('Shiny')
library("DT", lib.loc="~/R/R-3.4.2/library")
library("dashboardthemes", lib.loc="~/R/R-3.4.2/library")
shiny::runApp('C:/Users/D06279689E/Desktop/asdfg')
install.packages("DT")
# Inicializamos todo lo necesario
source("R/librerias.R")
source("R/inicio_twitter.R")
source("R/variables_globales.R")
source("R/funciones.R")
# Fase 1. Extraccion de datos desde la api
source("R/extraccion_cuentas.R")
source("R/extraccion_tweets.R")
historico.tweets
size(historico.tweets)
memory.size(historico.tweets)
memory.size()
memory.limit()
object.size(historico.tweets)
source("R/extraccion_seguidores.R")
source("R/extraccion_menciones.R")
source("R/extraccion_menciones.R")
users
# Graficas ----
# ·······························································································
output$temp <- renderPlot({
weatherData<- weatherData()
qplot(Dates, Temperature, data = weatherData, geom = "line")
})
output$rain <- renderPlot({
weatherData<- weatherData()
ggplot(data = weatherData(), aes(Dates, Rainfall)) +
geom_bar(stat = "identity")
})
output$maxTemp <- renderValueBox({
weatherData <- weatherData()
maxTemp <- max(weatherData$Temperature, na.rm = TRUE)
valueBox(maxTemp,
subtitle = "Maximum Temperature (celsius)",
icon     = icon("arrow-up"),
color    = "light-blue")
})
output$minTemp <- renderValueBox({
weatherData <- weatherData()
minTemp <- min(weatherData$Temperature, na.rm = TRUE)
valueBox(minTemp,
subtitle = "Minimum Temperature (celsius)",
icon     = icon("arrow-down"),
color    = "light-blue")
})
output$averageRainfall <- renderValueBox({
weatherData <- weatherData()
meanRain <- round(mean(weatherData$Rainfall, na.rm = TRUE),1)
valueBox(meanRain,
subtitle = "Average Monthly rainfall (mm)",
icon     = icon("cloud"),
color    = "orange")
})
# Tablas para visualizar
output$tb1 <- DT::renderDataTable({show_tabla(historico.cuentas)})
output$tb2 <- DT::renderDataTable(show_tabla(historico.tweets))
output$tb3 <- DT::renderDataTable(show_tabla(historico.menciones))
output$tb4 <- DT::renderDataTable(show_tabla(historico.seguidores))
}
# Graficas ----
# ·······························································································
output$temp <- renderPlot({
weatherData<- weatherData()
qplot(Dates, Temperature, data = weatherData, geom = "line")
})
output$rain <- renderPlot({
weatherData<- weatherData()
ggplot(data = weatherData(), aes(Dates, Rainfall)) +
geom_bar(stat = "identity")
})
output$maxTemp <- renderValueBox({
weatherData <- weatherData()
maxTemp <- max(weatherData$Temperature, na.rm = TRUE)
valueBox(maxTemp,
subtitle = "Maximum Temperature (celsius)",
icon     = icon("arrow-up"),
color    = "light-blue")
})
output$minTemp <- renderValueBox({
weatherData <- weatherData()
minTemp <- min(weatherData$Temperature, na.rm = TRUE)
valueBox(minTemp,
subtitle = "Minimum Temperature (celsius)",
icon     = icon("arrow-down"),
color    = "light-blue")
})
output$averageRainfall <- renderValueBox({
weatherData <- weatherData()
meanRain <- round(mean(weatherData$Rainfall, na.rm = TRUE),1)
valueBox(meanRain,
subtitle = "Average Monthly rainfall (mm)",
icon     = icon("cloud"),
color    = "orange")
})
# Tablas para visualizar
output$tb1 <- DT::renderDataTable({show_tabla(historico.cuentas)})
output$tb2 <- DT::renderDataTable(show_tabla(historico.tweets))
output$tb3 <- DT::renderDataTable(show_tabla(historico.menciones))
output$tb4 <- DT::renderDataTable(show_tabla(historico.seguidores))
}
# Datos ----
# ·······························································································
startTime <- as.numeric(Sys.time())
weatherData <- reactive({
invalidateLater(5000, session)
N <- min((as.numeric(Sys.time()) - startTime)/5 + 30, 1000)
read.csv("Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %>%
slice((n()-30):n())
})
# Datos ----
# ·······························································································
startTime <- as.numeric(Sys.time())
weatherData <- reactive({
invalidateLater(5000, session)
N <- min((as.numeric(Sys.time()) - startTime)/5 + 30, 1000)
read.csv("Data/weatherdata.csv") %>%
slice(1:N) %>%
mutate(Dates = as.POSIXct(Dates)) %%>
slice((n()-30):n())
})
# Inicializamos todo lo necesario
source("R/librerias.R")
source("R/inicio_twitter.R")
source("R/variables_globales.R")
source("R/funciones.R")
obtener_informacion <- function(seguidores) {
seguidores.unicos <- seguidores %>% select(user_id) %>% distinct()
N                 <- dim(seguidores.unicos)[1]
max.users         <- 90000
total.rep         <- ceiling(N / max.users)
info.seguidores   <- tibble()
for (i in 1:total.rep) {
inicio <- (i - 1) * max.users + 1
final  <- min(i * max.users, N)
info.seguidores <- rbind(info.seguidores, lookup_users(seguidores.unicos[inicio:final,]))
}
info.seguidores <- inner_join(info.seguidores, seguidores, by="user_id")
return(info.seguidores)
}
# Obtenemos la informacion de historico----
load("datos/historico_seguidores.RData")
# Obtenemos los seguidores de cada usuario
seguidores <- users %>% map( get_followers,
n                = 999999,
retryonratelimit = TRUE) %>%
map2_df(users, cbind) %>%
rename( "cuenta" = ".y[[i]]")
info.seguidores <- obtener_informacion(seguidores)
# Obtenemos informacion del alcance y repercusion
resumen.seg <- resumen_seguidores(info.seguidores) %>%
mutate(extraccion = Sys.Date(),
mes        = format(Sys.Date(), "%m/%Y"))
# Junto nueva informacion con la de meses anteriores
historico.seguidores <- anti_join(historico.seguidores, resumen.seg, by = c("cuenta", "mes")) %>%
bind_rows(resumen.seg)
# Guardamos los datos en el historico
save(historico.seguidores, file = "datos/historico_seguidores.RData")
info.seguidores <- rbind(info.seguidores, lookup_users(seguidores.unicos[inicio:final,]))
source("R/extraccion_tweets.R")
getCurRateLimitInfo:
q
getCurRateLimitInfo
getCurRateLimitInfo()
View(getCurRateLimitInfo())
